var shaders = {}
shaders["base_effect_shader_vert"] = "// base_effect_shader.vert\nattribute vec4 a_position;\nvarying vec2 v_texCoord;\nattribute vec2 a_texCoord;\nvoid main() {\n	vec4 zeroToOne = a_position / 1.0;\n	vec4 zeroToTwo = zeroToOne * 2.0;\n	vec4 clipSpace = zeroToTwo - 1.0;\n	gl_Position = vec4(clipSpace);\n	v_texCoord = a_texCoord;\n}";
shaders["base_layer_shader_vert"] = "// base_layer_shader.vert\nattribute vec4 a_position;\nuniform mat4 uMatrix;\nuniform mat4 localMatrix;\nvoid main() {\n	gl_Position = uMatrix * localMatrix * a_position;\n}";
shaders["base_layer_with_mask_shader_vert"] = "// base_layer_with_mask_shader.vert\nattribute vec4 a_position;\nuniform mat4 uMatrix;\nuniform mat4 localMatrix;\nvarying vec2 v_texCoord;\nattribute vec2 a_texCoord;\nvoid main() {\n	gl_Position = uMatrix * localMatrix * a_position;\n	v_texCoord = a_texCoord;\n}";
shaders["comp_layer_shader_frag"] = "// comp_layer_shader.frag\nprecision mediump float;\nuniform sampler2D u_image;\nvarying vec2 v_texCoord;\nvoid main() {\n	gl_FragColor = texture2D(u_image, v_texCoord);\n}";
shaders["comp_layer_shader_vert"] = "// comp_layer_shader.vert\nattribute vec4 a_position;\nuniform mat4 uMatrix;\nuniform mat4 localMatrix;\nvarying vec2 v_texCoord;\nattribute vec2 a_texCoord;\nvoid main() {\n	gl_Position = uMatrix * localMatrix * a_position;\n	v_texCoord = a_texCoord;\n}";
shaders["image_layer_shader_frag"] = "// image_layer_shader.frag\nprecision mediump float;\nuniform sampler2D u_image;\nvarying vec2 v_texCoord;\nvoid main() {\n	gl_FragColor = texture2D(u_image, v_texCoord);\n}";
shaders["image_layer_shader_vert"] = "// image_layer_shader.vert\nattribute vec4 a_position;\nuniform mat4 uMatrix;\nuniform mat4 localMatrix;\nvarying vec2 v_texCoord;\nattribute vec2 a_texCoord;\nvoid main() {\n	gl_Position = uMatrix * localMatrix * a_position;\n	v_texCoord = a_texCoord;\n}";
shaders["mask_shader_frag"] = "// mask_shader.frag\nprecision mediump float;\nuniform sampler2D original_image;\nuniform sampler2D mask_image;\nvarying vec2 v_texCoord;\nvoid main() {\n	vec4 original_color = texture2D(original_image, v_texCoord);\n	vec4 mask_color = texture2D(mask_image, v_texCoord);\n	gl_FragColor = vec4(original_color.rgb, mask_color.a * original_color.a);\n}";
shaders["mask_shader_vert"] = "// mask_shader.vert\nattribute vec4 a_position;\nvarying vec2 v_texCoord;\nattribute vec2 a_texCoord;\nvoid main() {\n	vec4 zeroToOne = a_position / 1.0;\n	vec4 zeroToTwo = zeroToOne * 2.0;\n	vec4 clipSpace = zeroToTwo - 1.0;\n	gl_Position = vec4(clipSpace);\n	v_texCoord = a_texCoord;\n}";
shaders["noop_effect_shader_frag"] = "// noop_effect_shader.frag\nprecision mediump float;\nvoid main() {\n	gl_FragColor = vec4(1.0,1.0,0.0,1.0);\n}";
shaders["puppet_pin_shader_frag"] = "// puppet_pin_shader.frag\nprecision mediump float;\nuniform sampler2D u_image;\nvarying vec2 v_texCoord;\nvoid main() {\n	gl_FragColor = texture2D(u_image, v_texCoord);\n}";
shaders["puppet_pin_shader_vert"] = "// puppet_pin_shader.vert\nattribute vec4 a_position;\nvarying vec2 v_texCoord;\nattribute vec2 a_texCoord;\nvoid main() {\n	vec4 zeroToTwo = a_position * 2.0;\n	vec4 clipSpace = zeroToTwo - 1.0;\n	gl_Position = vec4(clipSpace);\n	v_texCoord = a_texCoord;\n}";
shaders["ripple_shader_frag"] = "// ripple_shader.frag\nprecision mediump float;\nuniform sampler2D u_image;\nvarying vec2 vUv;\n\nvec2 fromPolar( vec2 uv ) {\n  uv = vec2( uv.x * cos( uv.y ), uv.x * sin( uv.y ) );\n  return uv + vec2( 0.5 );\n}\nvec2 toPolar( vec2 uv ) {\n  uv -= vec2( 0.5 );\n  return vec2( length( uv ), atan( uv.y, uv.x ));  \n}\n\n\n//sqrt(pow(0.5,2) + pow(0.5,2)) * 2\nfloat diagonal = 1.4142;\nfloat PI = 3.141592;\nfloat wave_width = 9.0;\nfloat wave_height = 0.008;\n\nvoid main() {\n	vec2 vUv_1 = vUv;\n	vUv_1 = toPolar(vUv_1);\n	float angle = (vUv_1.y + PI) * 180.0 / PI;\n	float segment = mod(angle, wave_width);\n	float segment_perc = segment / wave_width;\n	vUv_1.x += wave_height * sin(PI * segment_perc);\n	//vUv_1.x += vUv_1.x;\n	vec2 cart_vUv_1 = fromPolar(vUv_1);\n	if(cart_vUv_1.x < 0.0 || cart_vUv_1.x > 1.0 || cart_vUv_1.y < 0.0 || cart_vUv_1.y > 1.0) {\n		discard;\n	}\n	if(segment_perc < 0.5) {\n	}\n\n	gl_FragColor = texture2D(u_image, cart_vUv_1);\n}";
shaders["ripple_shader_vert"] = "// ripple_shader.vert\nattribute vec4 a_position;\nattribute vec2 a_texCoord;\nvarying vec2 v_texCoord;\nvarying vec2 vUv;\nvoid main() {\n	vec4 zeroToOne = a_position / 1.0;\n	vec4 zeroToTwo = zeroToOne * 2.0;\n	vec4 clipSpace = zeroToTwo - 1.0;\n	gl_Position = vec4(clipSpace);\n	vUv = a_texCoord;\n}";
shaders["solid_layer_shader_frag"] = "// solid_layer_shader.frag\nprecision mediump float;\nuniform vec4 colorUniform;\nvoid main() {\n	gl_FragColor = colorUniform;\n}";
shaders["solid_layer_with_mask_shader_frag"] = "// solid_layer_with_mask_shader.frag\nprecision mediump float;\nuniform vec4 colorUniform;\nvarying vec2 v_texCoord;\nuniform sampler2D mask_image;\nvoid main() {\n	vec4 mask_value = texture2D(mask_image, v_texCoord);\n	gl_FragColor = vec4(colorUniform.rgb, mask_value.r);\n}";
shaders["spherize_shader_frag"] = "// spherize_shader.frag\nprecision mediump float;\nuniform sampler2D u_image;\nvarying vec2 vUv;\n\nvec2 fromPolar( vec2 uv ) {\n  uv = vec2( uv.x * cos( uv.y ), uv.x * sin( uv.y ) );\n  return uv + vec2( 0.5 );\n}\nvec2 toPolar( vec2 uv ) {\n  uv -= vec2( 0.5 );\n  return vec2( length( uv ), atan( uv.y, uv.x ));  \n}\n\n\n//sqrt(pow(0.5,2) + pow(0.5,2)) * 2\nfloat diagonal = 1.4142;\nfloat PI = 3.141592;\nfloat wave_width = 9.0;\nfloat wave_height = 0.008;\n\nvoid main() {\n	vec2 vUv_1 = toPolar(vUv);\n	vUv_1.x += diagonal * sin(PI * vUv_1.x / diagonal);\n	vUv_1 = fromPolar(vUv_1);\n\n	gl_FragColor = texture2D(u_image, vUv_1);\n}";
shaders["tint_shader_frag"] = "// tint_shader.frag\nprecision mediump float;\nuniform sampler2D u_image;\nvarying vec2 v_texCoord;\nuniform float color_amount;\nuniform vec4 whiteToColor;\nuniform vec4 blackToColor;\n\nvoid main() {\n    vec4 textureValue = texture2D(u_image, v_texCoord);\n    float saturation = (textureValue.r + textureValue.g + textureValue.b) / 3.0;\n    vec4 textureMapped = blackToColor + (whiteToColor - blackToColor) * saturation;\n    gl_FragColor = vec4(mix(textureValue.rgb, textureMapped.rgb, color_amount),textureValue.a);\n}";
shaders["track_matte_shader_frag"] = "// track_matte_shader.frag\nprecision mediump float;\nuniform sampler2D original_image;\nuniform sampler2D mask_image;\nuniform float matte_type;\nvarying vec2 v_texCoord;\nvarying vec2 v_texCoord_mask;\nvoid main() {\n	vec4 original_vec = texture2D(original_image, v_texCoord);\n	vec4 mask_vec = texture2D(mask_image, v_texCoord_mask);\n	//vec4 mask_vec = texture2D(mask_image, v_texCoord_mask);\n	float multiplier;\n	if(v_texCoord_mask.x < 0.0 || v_texCoord_mask.y < 0.0 || v_texCoord_mask.x > 1.0 || v_texCoord_mask.y > 1.0) {\n		if(matte_type == 1.0 || matte_type == 3.0 || matte_type == 4.0) {\n			multiplier = 0.0;\n		} else if(matte_type == 2.0) {\n			multiplier = 1.0;\n		}\n	} else {\n		if(matte_type == 1.0) {\n			multiplier = mask_vec.a;\n		} else if(matte_type == 2.0) {\n			multiplier = 1.0 - mask_vec.a;\n		} else if(matte_type == 3.0) {\n			multiplier = (mask_vec.r + mask_vec.g + mask_vec.b) / 3.0;\n			//multiplier = 0.2126*mask_vec.r + 0.7152*mask_vec.g + 0.0722*mask_vec.b;\n			//multiplier = 0.299*mask_vec.r + 0.587*mask_vec.g + 0.114*mask_vec.b;\n			// multiplier = 0.33*mask_vec.r + 0.5*mask_vec.g + 0.16*mask_vec.b;\n		}  else if(matte_type == 4.0) {\n			multiplier = 1.0 - (mask_vec.r + mask_vec.g + mask_vec.b) / 3.0;\n		} \n		//gl_FragColor = mask_vec;\n	}\n	gl_FragColor = vec4(original_vec.rgb,multiplier * original_vec.a);\n	// gl_FragColor = texture2D(mask_image, v_texCoord);\n	//gl_FragColor = vec4(texture2D(u_image, v_texCoord).rgb,0.5);\n	//gl_FragColor = mix(original_vec,mask_vec,0.5);\n	// gl_FragColor = vec4(original_vec.rgb, 0.25);\n	//gl_FragColor = vec4(1.0,0.0,0.0,0.75);\n}";
shaders["track_matte_shader_vert"] = "// track_matte_shader.vert\nattribute vec4 a_position;\nuniform mat4 uMatrix;\n// TODO: Look into using a vec4 for both pairs of coords\nvarying vec2 v_texCoord;\nvarying vec2 v_texCoord_mask;\nattribute vec2 a_texCoord;\nvoid main() {\n	gl_Position = a_position;\n	vec4 zeroToOne = a_position;\n	vec4 zeroToTwo = zeroToOne * 2.0;\n	vec4 clipSpace = zeroToTwo - 1.0;\n	gl_Position = clipSpace;\n	//gl_Position = a_position;\n	v_texCoord = a_texCoord;\n	v_texCoord_mask = (uMatrix * vec4(a_texCoord,1,1)).xy;\n}";
shaders["twirl_shader_frag"] = "// twirl_shader.frag\nprecision mediump float;\nuniform sampler2D u_image;\nvarying vec2 vUv;\nuniform float angle;\nuniform float radius;\nuniform vec2 center;\n\nvec2 fromPolar( vec2 uv ) {\n  uv = vec2( uv.x * cos( uv.y ), uv.x * sin( uv.y ) );\n  return uv + vec2( 0.5 ) + center;\n}\nvec2 toPolar( vec2 uv ) {\n  uv -= vec2( 0.5 ) + center;\n  return vec2( length( uv ), atan( uv.y, uv.x ));  \n}\n\nfloat diagonal = 1.4142; //sqrt(pow(0.5, 2.0) + pow(0.5, 2.0)) * 2.0;\n\nvoid main() {\n	vec2 vUv_1 = toPolar(vUv);\n	if(vUv_1.x < diagonal * radius) {\n		float perc = vUv_1.x / (diagonal * radius);\n		perc = (cos(perc * 3.141592) + 1.0) / 2.0;\n		vUv_1.y += radians(-angle * perc);\n	}\n	vec2 cart_vUv_1 = fromPolar(vUv_1);\n	if(cart_vUv_1.x < 0.0 || cart_vUv_1.x > 1.0 || cart_vUv_1.y < 0.0 || cart_vUv_1.y > 1.0) {\n		discard;\n	} else {\n		gl_FragColor = texture2D(u_image, cart_vUv_1);\n	}\n}";
shaders["twirl_shader_vert"] = "// twirl_shader.vert\nattribute vec4 a_position;\nattribute vec2 a_texCoord;\nvarying vec2 v_texCoord;\nvarying vec2 vUv;\nvoid main() {\n	vec4 zeroToOne = a_position / 1.0;\n	vec4 zeroToTwo = zeroToOne * 2.0;\n	vec4 clipSpace = zeroToTwo - 1.0;\n	gl_Position = vec4(clipSpace);\n	vUv = a_texCoord;\n}";
function get_shader(name) {
return shaders[name];
}
